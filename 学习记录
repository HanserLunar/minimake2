学习途径：deepseek，csdn博客，bilibili。


					1,git
git是强大的文档管理工具，它可以记录工程文件的每次修改，也能利用分支尝试开发新功能而不损坏主代码。若是对某次修改不满意，我们可以随时回溯到某次提交。

大多时候git操作仅需三个命令：git add .    把所有修改送入缓冲区
			  git commit     把缓冲区全部内容送入本地git仓库 	 
			   git push      把本地仓库备份到github
两个查询命令：git log    查询提交日志 
	    git status   查看缓冲区

此外还有一些命令  git init  初始化本地仓库
	git remote add origin git@github.com:your-username/your-repo-name.git  关联远程仓库
		git clone [url]  克隆远程仓库
		
		

					2，Makefile语法
什么是Makefile？
Makefile是一种文本文件，包含了整个项目的构建规则。其基本结构是
target： dependency
	n*recipe
target是目标文件，这是每个基本结构的最后归宿。
dependency是依赖，构造目标文件时可能需要用到的文件
recipe是配方，是构造目标的方法
除了基本结构外，还有变量。变量类似于define，是单纯的文本替换
结构是 key=value，需要使用时其结构为 $(key),make工具会把这个结构解释成 value

自动变量 	 $@	当前规则中的目标文件名
		 $<	当前规则中的第一个依赖文件名
		 $^	当前规则中所有依赖文件的列表
		 $?	比目标文件新的所有依赖文件的列表	
		 
伪目标 结构：.PHONY：fake_target
作用：伪目标定义的target并不与文件关联，仅仅是一种动作的标签。我想有些操作不好放在某个recipe里，故可以用伪目标实现这些操作。



					3，字符串读写和文件操作
makefile本质是一种文本文件，因此文件读取和字符串处理是重点。
以下是本次项目利用到的标准库的函数：
strlen()：返回值是字符串的有效长度，遇到第一个\0字符结束
strcmp(const char *str1, const char *str2):比较str1和str2大小，相等返回0，str1>str2返回1，反之-1
strcpy(char* dest, const char* src):将src字符串拷贝到dest所指的地址，返回值是dest字符串的起始地址
strcspn(const char *str1, const char *str2):找到str1中第一个出现在str2中的字符的位置，返回值是这个位置的索引
fopen(const char *filename, const char *mode):打开第一个参数所指的地址的文件，第二个参数指打开做什么，返回值是指向这个文件的文件指针
fclose(FILE *stream):关闭先前打开的文件
fprintf（FILE *stream, const char *format, ...）：与printf类似，但这个可以指定输出目标，stream是指向 FILE 对象的指针，表示输出目标文件


文件读取时有个值得注意的地方，我们要读取的Makefile文件并非十分规范且工整，需要我们对文件进行预处理。
第一层的预处理应包含	过滤空行（仅包含空白字符的行）（长度为0的行直接跳过）
			去除行尾空格	（从末尾不断把空格‘ ’换成结束符，直到遇到非空格或缩进）
			去除注释（#后的内容）包括去除注释后的空行和行尾空格 （把#改成结束符）
第二层的预处理应包含 	规整格式，利用空格‘ ’分割字符串，在排列成符合后续处理需求的格式。
			（创建足够长的暂存字符串，将分割的字符串依次拼接）


文件时间读取：stat(const char *pathname, struct stat *statbuf) ：用于获取文件或目录的详细信息，包括文件大小、权限、时间戳等。参数是文件地址和用于存储获取到的文件信息的指针
	      char* ctime() 函数将 time_t 类型的时间戳转换为人类可读的字符串格式
用法：ctime（statbuf.st_atime）
通过比较返回值的大小可以确定哪个文件更新（更新的文件返回值更大） 




					4，ubuntu操作系统的使用
Bash:一种交互式命令工具，是用户与操作系统内核的桥梁。它接收用户的命令，将其解释并传递给操作系统内核来执行。
常用命令：ls	列出目录内容
	  cd	切换目录
	  pwd	当前目录的绝对路径
	  mdkir 创建新目录
	  rmdir 移除空目录
	  rm	删除文件或目录
	  mv	复制文件或目录
	  touch 创建空文件或更新文件时间戳
	  cat	查看文件全部内容
	  echo  打印信息
	  
gcc:是一个功能强大的开源编译器系统，支持多种编程语言。
常用命令：
	# 指定输出文件名
	gcc hello.c -o hello

	# 只预处理，不编译
	gcc -E hello.c -o hello.i

	# 只编译不汇编，生成汇编代码
	gcc -S hello.c -o hello.s

	# 只编译不链接，生成目标文件
	gcc -c hello.c -o hello.o
	
	#多文件编译
	gcc main.c utils.c math.c -o myprogram

					5，图算法
图算法可以表示多个东西的相互关系。
概念：
	顶点：某种具体物体的抽象表示
	边：物体间关系的抽象表示
	有向图：有方向的边和顶点组成的图形
	无向图：无方向的边和顶点组成的图形
	邻接矩阵：用二维矩阵的方式表达顶点和边，添加和删除顶点较为麻烦，但查询十分方便
	邻接链表：用链表的方式表达顶点和边，添加和删除顶点较为简单，但查询十分困难
	有权图：边不仅代表连接关系，边还有权重
	入度：指向同一个顶点的边的数目
	出度：从同一个顶点引出的边的数目
Makefile文件应该是一个固定的文本文件，目标和依赖的数量是确定的，因此用邻接矩阵的方式更为合适。

图遍历：广度优先算法  深度优先算法
广度优先：从指定顶点开始，逐层向外遍历。创建一个队列，把和正在拜访的顶点有连接关系的顶点全都加入队列中，在队列中选择下一个要拜访的顶点，反复进行上述过程直到可以拜访的顶点全部被拜访。

深度优先：从指定顶点开始不断拜访与其有连接关系的未被拜访过的顶点，若没有顶点可拜访，则回退到之前的顶点直到可以寻找到下一个未被拜访的顶点。可用递归实现。

Kahn算法：用于判断图是否为有向无环图（DAG）。
操作：将入度为0的顶点加入队列，从队列中取出顶点，删去该顶点及该顶点的连接关系，即让与该顶点连接的顶点的入度减1，再次寻找入度为0的顶点，把它加入队列，重复上述过程直到队列为空。若最后仍有顶点的入度不为0，则可认定图有环。


					6，输出命令及进程
进程是什么？进程是正在执行的程序的实例，包含代码数据堆栈等，每个进程有独立的地址空间，相互隔离。
创建进程：fork（）
如果执行成功, 在父进程中将返回子进程(新创建的进程) 的 PID, 在子进程将返回 0,以区别父子进程，通过判断返回值可以让父子进程执行不同的程序块。如果执行失败,则在父进程中返回-1。

等待进程：wait（int* status）
参数 status 用来保存被收集进程退出时的一些状态
进程一旦调用了 wait,就立即阻塞自己,由 wait 自动分析是否当前进程的某个子进程已经退出,如果让它找到了这样一个已经变成僵尸的子进程,wait 就会收集这个子进程的信息,并把它彻底销毁后返回;如果没有找到这样一个子进程,wait 就会一直阻塞在这里,直到有一个出现为止。
	  waitpid(pid_t pid,int *status,int options)
参数：pid>0时,只等待进程 ID 等于 pid 的子进程,不管其它已经有多少子进程运行结束退出了,只要指定的子进程还没有结束,waitpid 就会一直等下去。
     pid=-1时,等待任何一个子进程退出,没有任何限制,此时 waitpid 和 wait 的作用一模一样。
     pid=0时,等待与调用进程同进程组的任何子进程，如果子进程已经加入了别的进程组,waitpid 不会对它做任何理睬。
     pid<-1 时,等待进程组ID等于pid绝对值的任何子进程
options:WNOHANG 非阻塞模式：如果没有子进程退出，立即返回0

进程退出：main函数的return，exit（）用于正常退出，_exit()用于立即退出，不进行清理。异常退出有abort()，主动申请异常终止。

exec 函数族：作用是运行第一个参数指定的可执行程序。
但其工作过程与 fork 完全不同, fork 是在复制一份原进程,而 exec 函数执行第一个参数指定的可执行程序之后,这个新程序运行起来后也是一个进程,而这个进程会覆盖原有进程空间,即原有进程的所有内容都被新运行起来的进程全部覆盖了,所以 exec 函数后面的所有代码都不再执行,但它之前的代码当然是可以被执行的
execvp(const char *file, char *const argv[]):
在当前进程中运行其他程序，相较于其他exec函数，可以自动搜索path。argv[]要以NULL结尾。


WEXITSTATUS() 是一个用于从进程退出状态中提取退出码的宏。
作用是从 wait() 或 waitpid() 返回的状态值中提取子进程的退出状态码，将内核返回的原始状态值转换为有意义的退出码。

					7，哈希表
什么是哈希表？
	数组，查找方便，但删除和插入较困难，链表，插入和删除方便，但查找较困难，哈希表则是两者的混合使用，可以实现数据的快速插入、删除和查找。
	
哈希表的基本结构是节点，节点存储了key和value，以及指向下一个节点的指针next。key是该节点的名字，是找到该节点的关键，value是节点存储的数据，是节点存在的理由，next是用来寻找节点的桥梁。

节点之上有哈希表，哈希表是一个数组，数组存储了节点链表的头指针。通过哈希函数，我们可以找到key所在的链表的头指针，接着遍历链表即可找到所需的key。

数据结构之外有哈希函数，哈希函数的输入是key（一般来说key是字符串），输出是一个不大于哈希表长度的无符号整数，即哈希表的索引。一个好的哈希函数应该是计算速度快，输出分布均匀，输出确定的，确保哈希表充分利用，同一个key输入能得到同一个索引。

DJB2哈希：核心公式 hash=hash*33+c 。  33哪来的？magic！初始值5381哪来的？magic！c是字符的阿斯克值。最后输出应该限制在表长内，因此输出是 hash%table_size







